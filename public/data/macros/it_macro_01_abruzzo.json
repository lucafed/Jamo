// scripts/build_macro_it_abruzzo.mjs
// Build/expand macro for Abruzzo (auto-only) using bbox places (IT)
// Inputs:
// - public/data/macros/it_macro_01_abruzzo.json (optional seed)
// - public/data/places_bbox_abruzzo_neighbors.json
// Output:
// - public/data/macros/it_macro_01_abruzzo.json

import fs from "fs";
import path from "path";

const MACRO_PATH = path.join(process.cwd(), "public", "data", "macros", "it_macro_01_abruzzo.json");
const BBOX_PATH  = path.join(process.cwd(), "public", "data", "places_bbox_abruzzo_neighbors.json");

function norm(s) {
  return String(s ?? "")
    .toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]+/g, " ")
    .trim();
}

function readJson(p, fallback = null) {
  try {
    if (!fs.existsSync(p)) return fallback;
    return JSON.parse(fs.readFileSync(p, "utf8"));
  } catch {
    return fallback;
  }
}

function clamp(n, a, b) { return Math.max(a, Math.min(b, n)); }

function beautyFromPop(pop, tags) {
  const t = new Set((tags || []).map(x => norm(x)));
  let s = 0.72;
  if (Number.isFinite(pop) && pop > 0) {
    // leggero boost per città "utili" (monetizzabili)
    if (pop >= 80000) s += 0.05;
    if (pop >= 200000) s += 0.06;
  }
  if (t.has("mare") || t.has("spiagge")) s += 0.07;
  if (t.has("famiglie") || t.has("bambini") || t.has("attivita")) s += 0.06;
  if (t.has("storia")) s += 0.03;
  if (t.has("natura")) s += 0.03;
  return clamp(s, 0.60, 0.98);
}

function typeFromTags(tags) {
  const t = new Set((tags || []).map(x => norm(x)));
  if (t.has("mare") || t.has("spiagge")) return "mare";
  if (t.has("famiglie") || t.has("bambini") || t.has("attivita")) return "bambini";
  if (t.has("storia")) return "storia";
  if (t.has("natura")) return "natura";
  return "borgo";
}

function whyFromTags(name, tags) {
  const t = new Set((tags || []).map(x => norm(x)));
  const why = [];
  if (t.has("mare") || t.has("spiagge")) {
    why.push("Mare e passeggiata sul lungomare / spiagge vicine.");
    why.push("Ottimo per una gita facile e monetizzabile (tour, stabilimenti, hotel).");
  }
  if (t.has("famiglie") || t.has("bambini") || t.has("attivita")) {
    why.push("Ideale per famiglie: attività e cose da fare anche con bambini.");
    why.push("Perfetto per esperienze prenotabili (biglietti, parchi, visite).");
  }
  if (t.has("natura")) {
    why.push("Natura scenografica, perfetta per foto e passeggiate.");
  }
  if (t.has("storia")) {
    why.push("Tappa culturale interessante (storia/monumenti).");
  }
  if (why.length === 0) {
    why.push(`Posto valido e visitabile: ${name}.`);
    why.push("Buono per una gita nel tempo scelto.");
  }
  return why.slice(0, 3);
}

function main() {
  const seed = readJson(MACRO_PATH, null);
  const bbox = readJson(BBOX_PATH, null);

  if (!bbox || !Array.isArray(bbox.places)) {
    console.error("Missing/invalid bbox:", BBOX_PATH);
    process.exit(1);
  }

  const macro = seed ?? {
    id: "it_macro_01_abruzzo",
    name: "Macro 01 — Abruzzo (AUTO-ONLY) — Mete stabili offline",
    version: "3.0.0",
    updated_at: new Date().toISOString().slice(0,10),
    coverage: {
      primary_region: "Abruzzo",
      neighbors_regions: ["Lazio","Marche","Molise","Umbria"]
    },
    rules: {
      mode: "car_only",
      offline_and_stable: true,
      prefer_primary_region_first: true,
      fallback_allow_neighbors_if_few_results: true
    },
    schema: {
      place_fields: ["id","name","type","area","lat","lon","tags","visibility","beauty_score","why"]
    },
    places: []
  };

  macro.updated_at = new Date().toISOString().slice(0,10);

  const existing = Array.isArray(macro.places) ? macro.places : [];
  const seenId = new Set(existing.map(p => String(p.id)));
  const seenName = new Set(existing.map(p => norm(p.name)));

  // Aggiunte massicce ma controllate (evita macro gigante ingestibile)
  const ADD_LIMIT_TOTAL  = 900;   // puoi alzare, ma occhio a peso PWA
  const ADD_LIMIT_MARE   = 320;
  const ADD_LIMIT_FAMILY = 260;

  let addTotal = 0, addMare = 0, addFam = 0;

  // ordina per “utilità”: pop alto prima (più monetizzabile)
  const sorted = bbox.places.slice().sort((a,b) => (Number(b.population||0) - Number(a.population||0)));

  for (const p of sorted) {
    if (addTotal >= ADD_LIMIT_TOTAL) break;

    const id = String(p.id);
    const name = String(p.name || "").trim();
    const lat = Number(p.lat);
    const lon = Number(p.lon);

    if (!id || !name || !Number.isFinite(lat) || !Number.isFinite(lon)) continue;
    if (seenId.has(id) || seenName.has(norm(name))) continue;

    const tags = Array.isArray(p.tags) ? p.tags : [];
    const tset = new Set(tags.map(x => norm(x)));

    const isMare = tset.has("mare") || tset.has("spiagge");
    const isFam  = tset.has("famiglie") || tset.has("bambini") || tset.has("attivita");

    // vogliamo soprattutto mare e family perché hai pochi risultati a 60 min
    if (isMare && addMare >= ADD_LIMIT_MARE) continue;
    if (isFam && addFam >= ADD_LIMIT_FAMILY) continue;

    // se non è mare né family, la prendiamo solo se pop alta (città/borghi utili)
    const pop = Number(p.population || 0);
    if (!isMare && !isFam && pop < 25000) continue;

    const entry = {
      id,
      name,
      type: typeFromTags(tags),
      area: "Dintorni Abruzzo",
      lat,
      lon,
      tags: [...new Set([...(tags||[]), "auto"])],
      visibility: (p.visibility || "chicca"),
      beauty_score: Number(beautyFromPop(pop, tags).toFixed(2)),
      why: whyFromTags(name, tags)
    };

    existing.push(entry);
    seenId.add(id);
    seenName.add(norm(name));

    addTotal++;
    if (isMare) addMare++;
    if (isFam) addFam++;
  }

  macro.places = existing;

  fs.mkdirSync(path.dirname(MACRO_PATH), { recursive: true });
  fs.writeFileSync(MACRO_PATH, JSON.stringify(macro), "utf8");

  console.log("Saved macro:", MACRO_PATH);
  console.log("Total places:", macro.places.length);
  console.log("Added total:", addTotal, "mare:", addMare, "family:", addFam);
}

main();
